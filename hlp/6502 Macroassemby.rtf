{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deftab708{\fonttbl{\f0\fswiss\fprq2\fcharset0 Helv;}{\f1\fmodern\fprq1\fcharset0 Courier;}{\f2\fnil\fcharset0 Helv;}{\f3\fswiss\fcharset238{\*\fname Arial;}Arial CE;}{\f4\fmodern\fprq1\fcharset238{\*\fname Courier New;}Courier New CE;}}
\viewkind4\uc1\pard\lang1045\ul\f0\fs20 6502 Macroassembly directive description\ulnone\par
\b\f1\fs32\page\super\b0\f0\fs12 +K#$\nosupersub\b\f1\fs32 .ASCIS\b0\f0\fs20\par
\f2 Directive defining values of single bytes using passed string argument. Last byte has toggled (XOR-ed) most significant bit.\par
\f0\par
S\f3 yntax\f0 :\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .ASCIS <expr> | txtexpr \{ , <expr> | txtexpr \}\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1 alpha: .ASCIS "ABC" ; generates bytes $41, $42, $C3\cell\row
\intbl beta:  .ASCIS "Stop",$D ; generates bytes \lquote S\rquote , \lquote t\rquote , \lquote o\rquote , \lquote p\rquote , $8D\cell\row
\pard\f0\par
Description:\par
\pard\fi284\sb40\sa40 .ASCIS directive is helpful to generate string with it's end marked by toggling most significant bit.\par
\pard\b\f1\fs32\page\super\b0\f0\fs12 +K#$\nosupersub\b\f1\fs32 .BYTE\b0\f0\fs20  \f3 or\f0  \b\f1\fs32 .DB\b0\f0\fs20  \f3 or\f0  \b\f1\fs32 .ASCII\b0\f0\fs20\par
\f2 Directive defining values of single bytes using passed arguments.\par
\f0\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .DB <expr> | txtexpr \{ , <expr> | txtexpr \}\cell\row
\intbl [<label>[:]] .BYTE <expr> | txtexpr \{ , <expr> | txtexpr \}\cell\row
\intbl [<label>[:]] .ASCII <expr> | txtexpr \{ , <expr> | txtexpr \}\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1 alpha: .DB "ABC", 0 ; generates bytes \lquote A\rquote , \lquote B\rquote , \lquote C\rquote , 0\cell\row
\intbl beta:  .DB %1, %1$  ; macro params; string length and string itself\cell\row
\intbl  .BYTE <[alpha-1], >[alpha-1]\cell\row
\intbl  .ASCII "Text"\cell\row
\pard\f0\par
Description:\par
\pard\fi284\sb40\sa40 .DB (.BYTE, .ASCII) directive generates and defines single byte values. Input data might be entered in numerical or string form. Numerical expressions are also accepted.\par
\pard\par
Example:\par
\f1 msg:\tab .DB "Out of memory", 0\par
\b\fs32\page\super\b0\f0\fs12 +K#$\nosupersub\b\f1\fs32 .WORD\b0\f0\fs20  or \b\f1\fs32 .DW\b0\f0\fs20\par
\f2 Directive defining word values. Words are written according to low-endian 6502 convention: low byte first, high byte follows.\f0\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .DW expr \{ , expr \}\cell\row
\intbl [<label>[:]] .WORD expr \{ , expr \}\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1 alpha: .DW $1234, 0 ; generates sequence $34, $12, 0, 0\cell\row
\intbl beta:  .WORD alpha\cell\row
\intbl        .WORD alpha-1, beta\cell\row
\pard\b\fs32\page\super\b0\f0\fs12 +K#$\nosupersub\b\f1\fs32  .DBYTE\b0\f0\fs20  or \b\f1\fs32 .DD\b0\f0\fs20\par
Directive defining double byte values. Double bytes numbers are written according to big-endian convention: high byte first, low byte follows.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .DD expr \{ , expr \}\cell\row
\intbl [<label>[:]] .DBYTE expr \{ , expr \}\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1 alpha: .DD $1234, 0 ; generates sequence $12, $34, 0, 0\cell\row
\intbl beta:  .DBYTE alpha\cell\row
\intbl        .DBYTE alpha-1, beta\cell\row
\pard\page\super\f0\fs12 +K#$\nosupersub\b\f1\fs32  .STR\b0\f0\fs20  or \b\f1\fs32 .STRING\b0\f0\fs20\par
Directive defining byte values using passed string argument. First generated byte contains string length. Rest of bytes are verbatim copies of string characters. String length is limited to 255 characters.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .STR expr \{ , expr \}\cell\row
\intbl [<label>[:]] .STRING expr \{ , expr \}\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1 alpha: .STRING "ABC", $D ; generates sequence 4, \lquote A\rquote , \lquote B\rquote , \lquote C\rquote , $0D\cell\row
\intbl beta:  .STR "Test string", $D, $A\cell\row
\intbl        .STR "AB", "CD", 13 ; generates: 5, \lquote A\rquote , \lquote B\rquote , \lquote C\rquote , \lquote D\rquote , $0D\cell\row
\pard\page\super\f4\fs12 +K#$\nosupersub\f1\fs20  \b\fs32 .DCB\b0\f0\fs20\par
Directive reserving memory area with initialization of reserved memory by given value.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .DCB expr [ , expr ]\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1 buf: .DCB $20,$FF  ; next $20 bytes is reserved and set to $FF\cell\row
\pard\b\fs32\page\super\b0\f0\fs12 +K# $\nosupersub\fs20  \b\f1\fs32 .RS\b0\f0\fs20  lub \b\f1\fs32 .DS\b0\f0\fs20\par
Directive reserving memory area by adding given value to the pointer of current location.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .RS expr\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1 buf: .RS $100 ; reserve $100 bytes\cell\row
\intbl      .RS size ; same as *= * + size\cell\row
\intbl\cell\row
\pard\f0\par
\b\f1\fs32\page\super\b0\f0\fs12 +K#$\nosupersub\b\f1\fs32 .OPT\b0\f0\fs20\par
Directive setting assembly options. The only allowed options are:\par
\par
\trowd\trgaph70\trleft-70\cellx1701\cellx9142\pard\intbl\b Option Name\b0\cell\b Meaning\b0\cell\row
\intbl Proc6502 \cell select basic command set of 6502 microprocessor\cell\row
\intbl Proc65c02 \cell select extended command set of 65c02, 6501 and other microprocessors\cell\row
\intbl Proc6501\cell ditto\cell\row
\intbl CaseSensitive \cell treat lowercase and uppercase letters in label names as different\cell\row
\intbl CaseInsensitive \cell treat lowercase and uppercase letters in label names as same\cell\row
\pard\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1  .OPT option_name \{ , option_name \}\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .OPT Proc65c02, CaseInsensitive \cell\row
\pard\b\fs32\page\super\b0\f0\fs12 +K#$\nosupersub\fs20  \b\f1\fs32 .ORG\b0\f0\fs20  lub \b\f1\fs32 *=\b0\f0\fs20\par
Directive setting code generation location.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .ORG expr\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  *= $1000  ; code location: $1000\cell\row
\intbl buf: .ORG * + $10 ; offset code location by $10 bytes,\cell\row
\intbl            ; label \lquote buf\rquote  will be set to previous code location address\cell\row
\pard\f0\page\super\fs12 +K#$\nosupersub\fs20  \b\f1\fs32 .START\b0\f0\fs20\par
Directive setting simulator entry (start) point address.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1  .START expr\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .START Start ; start program execution from \lquote Start\rquote  address\cell\row
\intbl  .START $A100 ; start program execution from $A100 address\cell\row
\pard\f0\par
Description:\par
\pard\fi284\sb40\sa40 .START directive selects simulator entry point. Simulator will attempt to launch program using given address. If there is no .START directive used, simulator tries to start execution using address specified by first .ORG directive. .START directive allows using forward referencing (unlike .ORG).\par
\pard\b\f1\fs32\page\super\b0\f0\fs12 +K#$\nosupersub\b\f1\fs32  .END\b0\f0\fs20\par
Directive finishing source code assembly.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .END\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1 fin: .END  ; rest of source code in current file won't be assembled\cell\row
\pard\f0\par
Description:\par
\tab .END directive finishes assembly process of the file it was placed in. Used in main source file finishes assembly in the line it is placed.\par
\page\super\fs12 +K#$\nosupersub\fs20  \b\f1\fs32 .INCLUDE\b0\f0\fs20\par
Directive including source file to assembly.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1  .INCLUDE txt_expr\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .INCLUDE "c:\\asm6502\\const_vals.65s"\cell\row
\intbl  .INCLUDE ".\\macros\\macros"\cell\row
\pard\f0\par
Description:\par
\pard\fi284\sb40\sa40 .INCLUDE directive includes given source code file. S\'b9 one wstawiane w miejscu wywo\'b3ania dyrektywy .INCLUDE. Pozwala to na \'b3atwe do\'b3\'b9czanie plik\'f3w z definicjami sta\'b3ych i makr.\f1\par
\pard\f0\page\super\fs12 +K#$\nosupersub\fs20  \b\f1\fs32 .MACRO\b0\f0\fs20\par
Directive opening macro definition.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 <label>[:] .MACRO [param \{, param\} [, ...]] | [...]\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1 PushX  .MACRO      ; parameterless macro\cell\row
\intbl Print: .MACRO ...  ; macro accepting any number of params\cell\row
\intbl Put:   .MACRO chr  ; macro accepting exactly one parameter\cell\row
\pard\f0\par
Description:\par
\pard\fi284\sb40\sa40 .MACRO directive defines block of code (macro definitions). Label placed before .MACRO becomes macro definition name and is placed in macro name dictionary (which is separate from label names dictionary).\par
After .MACRO directive one can place macro parameters and/or ellipsis (...). Parameter name can then be used in macro definition block. Defined parameters will be required when macro is used later in source code. To pass any number of parameters (also none) one can use ellipsis (...). If there are no params defined macro can be invoked without params only.\par
To use params inside macro definition one can use their names or consecutive numbers (starting from 1) preceded by '%' character. Param number zero (%0) has special meaning--it contains number of actual parameters macro was invoked with. Instead of numbers numeric expression can be used if they are enclosed in square brackets (for example %[.cnt+1]).\par
In macro invocation actual parameters are placed after macro name. Param expressions are separated by commas. All those expression are assembly time expressions. They get interpreted and calculated and result values are passed to macro definition.\par
All the labels starting with dot (.) are local to macro definition block and are not accessible nor visible from the outside code using macrodefinition. All the other labels are global. Macrodefinition code can use local labels (from the place it was invoked), global labels, as well as it's own local labels.\par
Macro definition parameters could be referenced with '$' suffix. If given param was passed as string it is still accessible as string using dollar sign. Accessing it without '$' suffix returns string length. Param 0$ has special meaning: macro name.\par
\pard\par
Example:\par
\f1 Put:\tab .MACRO chr\tab\tab ; print single character\par
\tab LDA #chr\tab\tab ; load value of parameter \lquote chr\rquote\par
\tab JSR sys_put_char\par
\tab .ENDM\par
; invocation:\par
\tab Put \rquote A\rquote\par
\par
Print:\tab .MACRO ...\tab ; printing\par
.cnt\tab .= 0\tab\tab\tab ; param counter\par
\tab .REPEAT %0\par
.cnt\tab .= .cnt + 1\par
\tab .IF .PARAMTYPE(%.cnt) == 2\tab ; text param?\par
\tab   JSR sys_print_text\tab ; string is placed *after* procedure call\par
\tab   .BYTE .STRLEN(%.cnt), %.cnt\par
\tab .ELSE\tab\tab\tab\tab\tab ; numerical param -> address of string\par
\tab   LDA #>%.cnt\tab\tab ; high address byte\par
\tab   LDX #<%.cnt\tab\tab ; low address byte\par
\tab   JSR sys_print\par
\tab .ENDIF\par
\tab .ENDR\par
\tab .ENDM\par
\f0\par
\par
\page\super\fs12 +K#$\nosupersub\fs20  \b\f1\fs32 .ENDM\b0\f0\fs20\par
Directive closing macro definition block. Check also \uldb .MACRO\ulnone\v cmd_macro\v0\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1  .ENDM\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .ENDM  ; end of macro definition\cell\row
\pard\b\fs32\page\super\b0\f0\fs12 +K#$\nosupersub\b\f1\fs32  .EXITM\b0\f0\fs20\par
Directive stopping macro inserting.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1  .EXITM\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .EXITM ; all the rest of macro code won't be inserted\cell\row
\intbl         ; in place it was invoked\cell\row
\pard\f0\par
\b\f1\fs32\page\super\b0\f0\fs12 +K#$\nosupersub\b\f1\fs32  .IF\b0\f0\fs20\par
Directive opening conditional assembly block.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1  .IF expr\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .IF .REF(alpha) ; if 'alpha' label was referenced\cell\row
\intbl  .IF a==5  ; if label 'a' equals 5\cell\row
\intbl  .IF b     ; if label 'b' has non-zero value\cell\row
\intbl  .IF %0>2  ; if macro invoked with more then two params\cell\row
\intbl  \cell\row
\pard\f0\par
\page\super\fs12 +K#$\nosupersub\fs20  \b\f1\fs32 .ELSE\b0\f0\fs20\par
Directive of conditional assembly.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1  .ELSE\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .ELSE  ; if condition after .IF directive wasn't <> 0\cell\row
\intbl    ; then following lines will be assembled\cell\row
\pard\par
\f0\page\super\fs12 +K#$\nosupersub\fs20  \b\f1\fs32 .ENDIF\b0\f0\fs20\par
Directive closing conditional assembly block.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1  .ENDIF\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .ENDIF ; end of conditional assembly block\cell\row
\pard\f0\par
\page\super\fs12 +K#$\nosupersub\fs20  \b\f1\fs32 .ERROR\b0\f0\fs20\par
Directive generation assembly error.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1  .ERROR [txtexpr]\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .ERROR "Required text parameter missing in macro " + %0$\cell\row
\pard\f0\par
\page\super\fs12 +K#$\nosupersub\b\f1\fs32 .REPEAT\b0\f0\fs20  lub \b\f1\fs32 .REPT\b0\f0\fs20\par
Directive opening block of source text to be repeated given number of times.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .REPEAT expr\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .REPEAT 10  ; repeat 10 times\cell\row
\intbl  .REPEAT %0  ; repeat as many times as number of macro params\cell\row
\intbl  .REPEAT 4\cell\row
\intbl     LSR\cell\row
\intbl  .ENDR\cell\row
\pard\par
\b\fs32\page\super\b0\f0\fs12 +K#$\nosupersub\b\f1\fs32 .ENDR\b0\f0\fs20\par
Directive closing block of source text to repeat.\par
\par
Syntax:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\b\f1 [<label>[:]] .ENDR\cell\row
\pard\b0\f0\par
Example:\par
\trowd\trgaph70\trleft-70\cellx9142\pard\intbl\f1  .ENDR\cell\row
\pard\b\fs32\page\b0\f0\fs20\par
}
 